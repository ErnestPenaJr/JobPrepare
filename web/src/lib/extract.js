const { synonymize } = require('./synonyms');

const KNOWN_SKILLS = [
  'python','django','javascript','typescript','node','sql','ms-sql','pl/sql','t-sql','transact-sql','sql server',
  'api','json','azure','power bi','r','sas','eviews','bootstrap','jquery','php','c#','coldfusion','html','css',
  'aws','gcp','docker','kubernetes','terraform','postgres','postgresql','mysql','oracle','mongodb','kafka','rabbitmq',
  'tableau','dbt','airflow','pandas','numpy','scikit','react','vue','angular','express','java','spring','.net','excel'
];

function toLines(text) { return (text || '').split(/\r?\n/); }
function lc(text) { return (text || '').toLowerCase(); }
function findSkills(text) { const T = lc(text); const found = new Set(); for (const s of KNOWN_SKILLS) { for (const syn of synonymize(s)) { if (T.includes(syn)) found.add(s); } } return [...found]; }
function extractSkillsFromSections(text){ const lines = toLines(text); const headerRe = /^(skills|technical skills|technologies|tools|stack|core competencies)\b[:]?/i; const collected = []; for (let i=0;i<lines.length;i++){ if (headerRe.test(lines[i])){ let buf = ''; for (let j=i+1;j<Math.min(i+4, lines.length); j++){ const l = lines[j].trim(); if (!l) break; buf += (buf ? ' ' : '') + l; } if (buf){ const tokens = buf.split(/[,/;|•]\s*/).map(t=>t.trim()).filter(Boolean); collected.push(...tokens); } } } return [...new Set(collected.map(lc))]; }
function inferYears(text) { const m = lc(text).match(/(\d+)\s*\+?\s*years/); if (m) return Number(m[1]); return 0; }
const STATE_NAMES = { texas: 'TX', california: 'CA', 'new york': 'NY', florida: 'FL', washington: 'WA', oregon: 'OR', colorado: 'CO', arizona: 'AZ', illinois: 'IL', georgia: 'GA', massachusetts: 'MA', virginia: 'VA', 'north carolina': 'NC', 'south carolina': 'SC', tennessee: 'TN', ohio: 'OH', michigan: 'MI', pennsylvania: 'PA' };
function detectLocation(text) { const t = lc(text || ''); const onsite = /(on[- ]site|onsite)/.test(t); const daysMatch = t.match(/\b(\d)\s*days?\s*(?:per|\/)?\s*week[^\n]*on[- ]?site/); const days = daysMatch ? Number(daysMatch[1]) : (/(monday.*friday.*on[- ]?site)/.test(t) ? 5 : null); let city = null, state = null; const mCityState = t.match(/\b([A-Za-z][A-Za-z .'-]{2,}),\s*(AL|AK|AZ|AR|CA|CO|CT|DC|DE|FL|GA|HI|IA|ID|IL|IN|KS|KY|LA|MA|MD|ME|MI|MN|MO|MS|MT|NC|ND|NE|NH|NJ|NM|NV|NY|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VA|VT|WA|WI|WV|WY)\b/); if (mCityState) { city = mCityState[1].trim().replace(/\.$/, ''); state = mCityState[2].toUpperCase(); } else { for (const [name, code] of Object.entries(STATE_NAMES)) { if (t.includes(name)) { state = code; break; } } const cities = ['houston','austin','dallas','san francisco','los angeles','seattle','denver','chicago','boston','atlanta','new york','miami','phoenix','portland']; const foundCity = cities.find((c)=> t.includes(c)); if (foundCity) city = foundCity.replace(/\b\w/g, (ch)=> ch.toUpperCase()); } return { city, state, onsite: !!onsite, days_on_site: days }; }
function extractTitleCompany(text){ const lines = toLines(text).map((l)=> l.trim()).filter(Boolean); let title = null; let company = null; for (const l of lines.slice(0, 15)) { let m; if (!title && (m = l.match(/^\s*(job\s*title|title|position|role)\s*[:\-]\s*(.+)$/i))) { title = m[2].trim(); } if (!company && (m = l.match(/^\s*(company|employer)\s*[:\-]\s*(.+)$/i))) { company = m[2].trim(); } if (!company && (m = l.match(/^About\s+([A-Z][A-Za-z0-9&.,\-\s]{1,60})$/))) { company = m[1].trim(); } } if (!title) { const cand = lines.find((l)=> l.length <= 80 && /[A-Za-z]/.test(l) && !l.endsWith(':')); if (cand) { const atParts = cand.split(/\sat\s/i); if (atParts.length === 2) { title = atParts[0].trim(); company = company || atParts[1].trim(); } else { title = cand.trim(); } } } if (title) title = title.replace(/[\s\-•|]+$/,''); if (company) company = company.replace(/[\s\-•|]+$/,''); return { title, company }; }
function extractDocument(text) { const skills = findSkills(text); const years = inferYears(text); const location = detectLocation(text); return { skills, years, location }; }
function buildJD(text) { const tc = extractTitleCompany(text || ''); return { title: tc.title || null, company: tc.company || null, location: detectLocation(text), requirements: { must_have: findSkills(text).filter((s) => ['python','django','azure','power bi','sql','api','json','r','sas','eviews'].includes(s)), nice_to_have: findSkills(text).filter((s) => ['r','sas','eviews','javascript','typescript'].includes(s)), }, experience_bounds: { min_years: inferYears(text) || 0, management_direct_reports: null, architect_only: false }, primary_stack: ['python','django'].filter((s)=> (text||'').toLowerCase().includes(s)), domain: [], stop_keywords: ['manufacturing','plant','factory','warehouse','warehousing','industrial','supply chain operations','logistics'], };
}
function buildCandidate(resumeText, coverLetterText) { const all = `${resumeText || ''}\n${coverLetterText || ''}`; const skills = [...new Set([ ...findSkills(all), ...extractSkillsFromSections(resumeText || '') ])]; const years_overall = Math.max(inferYears(resumeText), inferYears(coverLetterText), 0) || 0; const frameworks = skills.filter((s) => ['django','bootstrap','jquery','coldfusion'].includes(s)); const domains = /healthcare/.test(lc(all)) ? ['Healthcare IT'] : []; return { name: null, skills, frameworks, cloud: skills.includes('azure') ? ['Azure'] : [], bi: skills.includes('power bi') ? ['Power BI'] : [], data_science: skills.some((s)=> ['r','sas','eviews'].includes(s)) ? ['Stats'] : [], domains, years_overall, years_by_skill: {}, management: { direct_reports: 0, tech_lead_only: false }, location: detectLocation(all), resume_text: resumeText || '', cover_text: coverLetterText || '', };
}
function keywordDiff(jd, candidate) { const must = (jd.requirements && jd.requirements.must_have) || []; const pref = (jd.requirements && jd.requirements.nice_to_have) || []; const skillSet = new Set((candidate.skills || []).map((s)=> s.toLowerCase())); const fwSet = new Set((candidate.frameworks || []).map((s)=> s.toLowerCase())); const resumeL = (candidate.resume_text || '').toLowerCase(); const coverL = (candidate.cover_text || '').toLowerCase(); function sourcesFor(term){ const ls = synonymize(term.toLowerCase()); const sources = []; if (ls.some(s=> skillSet.has(s))) sources.push('skills'); if (ls.some(s=> fwSet.has(s))) sources.push('frameworks'); if (ls.some(s=> resumeL.includes(s))) sources.push('resume'); if (ls.some(s=> coverL.includes(s))) sources.push('cover'); return sources; } const mustProvenance = {}; const prefProvenance = {}; const mustMatched = must.filter((m)=> { const src = sourcesFor(m); if (src.length) mustProvenance[m.toLowerCase()] = src; return src.length > 0; }); const mustMissing = must.filter((m)=> !mustMatched.includes(m)); const prefMatched = pref.filter((m)=> { const src = sourcesFor(m); if (src.length) prefProvenance[m.toLowerCase()] = src; return src.length > 0; }); const prefMissing = pref.filter((m)=> !prefMatched.includes(m)); return { matched: mustMatched, missing: mustMissing, must: { matched: mustMatched, missing: mustMissing, provenance: mustProvenance }, preferred: { matched: prefMatched, missing: prefMissing, provenance: prefProvenance }, };
}
function gapAnalysis(jd, candidate) { const gaps = []; const { missing } = keywordDiff(jd, candidate); for (const m of missing) gaps.push(`Missing required skill: ${m}`); const minYears = (jd.experience_bounds && jd.experience_bounds.min_years) || 0; if ((candidate.years_overall || 0) < minYears) gaps.push(`Years overall below requirement: need ${minYears}`); return gaps; }
function generateCoverLetter(candidate, jd, today) { const name = candidate.name || 'Candidate'; const skills = (candidate.skills || []).slice(0, 8); const matches = keywordDiff(jd, candidate).matched; const lines = []; lines.push(`${today}`); lines.push(''); lines.push('Dear Hiring Manager,'); lines.push(''); lines.push(`I am writing to express interest in the ${jd.title || 'role'}. My background spans ${candidate.years_overall || 'several'} years with focus on the following relevant skills: ${matches.concat(skills).filter((v,i,a)=>a.indexOf(v)===i).join(', ')}.`); lines.push('I have delivered full‑stack solutions, collaborating with stakeholders and following modern SDLC practices. I am particularly aligned with your requirements around core technologies and data handling.'); lines.push(''); lines.push('Thank you for your consideration. I welcome the opportunity to discuss how my experience can contribute to your team.'); lines.push(''); lines.push('Sincerely,'); lines.push(name); return lines.join('\n'); }

module.exports = { extractDocument, buildJD, buildCandidate, gapAnalysis, keywordDiff, generateCoverLetter };
